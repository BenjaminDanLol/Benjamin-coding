int VaramountofPokemonPresented;
int filter;
if (filter > 2000) {
    if (filter >= 1400) {
        VaramountofPokemonPresented = (2000-filter) / 100;
    } else {
        VaramountofPokemonPresented = 6;
    }

else {
while (pokemonMap.size() < 4) {
    pokemonMap.clear();
    pokemonMapAllInclusive.forEach((key, value) -> {
        if (value < chosenFilter.get()){
            pokemonMap.put(key, value);
        } 
    });
    chosenFilter.addAndGet(50);
        } 
    }
}
chosenFilter.equals(200);

while (pokemonMap.size() < VaramountofPokemonPresented) {
    pokemonMap.clear();
    pokemonMapAllInclusive.forEach((key, value) -> {
        if (600 >= (1000 - chosenFilter.get()) && 600 <= 1000) {
            pokemonMap.put(key, value);
        }
    });
    chosenFilter.addAndGet(100);
}

then instead of going from bottom to highest we do the opposite. So:
    void filterElPokemon(int filter) {
        final AtomicInteger chosenFilter = new AtomicInteger(filter);


        Map<String, Integer> pokemonMap = new HashMap<>();
        Map<String, Integer> pokemonMapAllInclusive = new HashMap<>();
        Iterator<Map.Entry<String, JsonNode>> fields = typeMappingNode.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> entry = fields.next();
                pokemonMapAllInclusive.put(entry.getKey(), entry.getValue().asInt());
            }



        while (pokemonMap.size() < 4) {
        pokemonMap.clear();
        pokemonMapAllInclusive.forEach((key, value) -> {
            if (value < chosenFilter.get()){
                pokemonMap.put(key, value);
            } 
        });
        chosenFilter.addAndGet(50);
        }

}